---
description: 
globs: 
alwaysApply: false
---
# Route-Based Context & Routing Rules

## Core Patterns

### Route Definition
```typescript
// ✅ Functional exports with path constants
export const sectionRoutes = (userRole?: string): RouteObject[] => [
  {
    path: sectionPath.default,
    element: <SectionLayout />,
    children: [
      { index: true, element: <SectionHome /> },
      { path: sectionPath.settings, element: <SectionSettings /> }
    ]
  }
];

// ✅ Path constants in separate files
const defaultPath = "/section-name";
export const sectionPath = {
  default: defaultPath,
  subsection: `${defaultPath}/subsection`,
  settings: `${defaultPath}/settings`
} as const;
```

### Context Management
```typescript
// ✅ Route-specific context with typed hooks
export const SectionProvider = ({ children }: PropsWithChildren) => {
  const [state, setState] = useState();
  const contextValue = useMemo(() => ({ state, setState }), [state]);
  
  return (
    <SectionContext.Provider value={contextValue}>
      {children}
    </SectionContext.Provider>
  );
};

// ✅ Typed hook with error boundary
export const useSectionContext = () => {
  const context = useContext(SectionContext);
  if (!context) throw new Error('useSectionContext must be used within SectionProvider');
  return context;
};

// ✅ Wrap routes with context
{
  path: sectionPath.default,
  element: (
    <SectionProvider>
      <SectionLayout />
    </SectionProvider>
  ),
  children: [...]
}
```

## Authentication & Performance

### Route Guards & Role-Based Access
```typescript
// ✅ Dynamic route filtering
const routes = useMemo(() => {
  if (!isAuthenticated) return [...authRoutes()];
  const baseRoutes = [...dashboardRoutes()];
  if (role === 'admin') baseRoutes.push(...adminRoutes());
  return baseRoutes;
}, [isAuthenticated, role]);

// ✅ Role metadata on routes
{
  path: adminPath.users,
  element: <UserManagement />,
  meta: { roles: ['admin', 'super-admin'] }
}
```

### Lazy Loading & Memoization
```typescript
// ✅ Lazy components with Suspense
const Component = lazy(() => import('../pages/Component'));
{
  path: path.component,
  element: (
    <Suspense fallback={<RouteLoader />}>
      <Component />
    </Suspense>
  )
}

// ✅ Memoize expensive calculations
const allRoutes = useMemo(() => [
  ...baseRoutes(isAuthenticated),
  ...conditionalRoutes(role)
], [isAuthenticated, role]);
```

## Error Handling & Testing

### Error Boundaries
```typescript
// ✅ Route-level error boundaries
{
  path: sectionPath.default,
  element: (
    <ErrorBoundary fallback={<SectionError />}>
      <SectionLayout />
    </ErrorBoundary>
  )
}
```

### Testing Utilities
```typescript
// ✅ Route testing helper
const renderWithRouter = (component: React.ReactElement, initialPath = '/') => {
  window.history.pushState({}, 'Test page', initialPath);
  return render(
    <BrowserRouter>
      <AuthProvider>{component}</AuthProvider>
    </BrowserRouter>
  );
};
```

## Naming Conventions

- **Files**: `sectionName.routes.tsx`, `sectionName.path.ts`, `SectionNameContext.tsx`
- **Exports**: `sectionNameRoutes`, `sectionNamePath`, `SectionNameProvider`, `useSectionNameContext`
- **JSDoc**: Document route purpose, params, and role requirements

## Key Rules

1. **Always use functional route exports** with path constants
2. **Create route-specific contexts** for shared state within route trees  
3. **Memoize expensive operations** and context values
4. **Handle authentication at routing level** with dynamic route filtering
5. **Use lazy loading** with Suspense for performance
6. **Add error boundaries** to route sections
7. **Never hardcode paths** - use path constants
8. **Test routes and contexts** with proper mocks